* AtCoder submit まとめ

** AtCoder Beginner Contest 214
*** A問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc214_a

    提出: [[abc214/a.cpp]]

    素直に条件分岐．
    
*** B問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc214_b

    提出: [[abc214/b.cpp]]

    3重ループで条件を満たすときのみans++．

*** C問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc214_c

    提出: [[abc214/c.cpp]]

    直接宝石を渡された時間と，前の人からもらった時間を比較して早いほうの時間を採用した．
    途中で直接渡された場合，2周しないと更新しきれないので2回同じ処理を回してAC．
    
*** D問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc214_d

    提出: [[abc214/d.cpp]]

    解説見ながら解いた．大事なのは主客転倒をして重みwが計算された回数を数える方向にシフトすること．
    小さいものから順番に数えつつUnion-Findでグループ化していけばいい感じで解けた．
    Union-Findの実装はアルゴリズムとデータ構造（通称けんちょん本）を参考にした．

    主客転倒について

    https://physics0523.hatenablog.com/entry/2020/01/12/052513

    解説

    https://blog.hamayanhamayan.com/entry/2021/08/15/034729
   
** AtCoder Beginner Contest 213
*** A問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc213_a

    提出: [[abc213/a.cpp]]

    両辺に対してAをxorすると，出力は A xor B，つまり ~A^B~ で良い．

*** B問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc213_b

    提出: [[abc213/b.cpp]]

    一番大きい値と二番めに大きい値を保持してforを回す．
    pairに位置を持たせて入力でsortして下から2番目の位置の参照でも解ける．

*** C問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc213_c

    提出: [[abc213/c.cpp]]
    
    力技で隣の数との差分の和を引いていくループを実装して計算したけど
    この問題は座標圧縮という典型アルゴリズムそのものらしい．

    座標圧縮の解説

    https://blog.hamayanhamayan.com/entry/2021/08/09/010106

    https://drken1215.hatenablog.com/entry/2021/08/09/235400


    座標圧縮で実装

    map [[abc213/c_map.cpp]]
    
    sort [[abc213/c_sort.cpp]]

*** D問題
    問題: https://atcoder.jp/contests/abc213/tasks/abc213_d

    提出: [[abc213/d.cpp]]
    
    深さ優先探索だ！！！となったけど実装がさっぱりだったので下記の参考サイトの
    DFSの実装を参考に書いたら通った．なんかsortするときのループの回数が一回足りてなくて
    ハマった…．

    DFS解説

    https://qiita.com/drken/items/4a7869c5e304883f539b
